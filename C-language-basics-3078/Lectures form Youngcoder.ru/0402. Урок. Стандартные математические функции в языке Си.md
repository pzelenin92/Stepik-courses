>[!info]
>Урок с сайта youngcoder
>[Урок 4](https://youngcoder.ru/lessons/4/math_function.php/)


Математические вычисления не ограничиваются лишь арифметическими действиями. Кроме них, можно ещё встретить корни, модули, логарифмы, тригонометрические функции и пр. Научимся же использовать подобные функции в своих программах.

Для использования математических функций нужно подключить заголовочный файл math.h. В ней определено много различных функций, но мы пока рассмотрим следующие:

Некоторые математические функции:

fabs(x) модуль числа x  
sqrt(x) квадратный корень из числа x  
sin(x) синус числа x (х в радианах)  
cos(x) косинус числа x (х в радианах)  
pow(x, y) вычисление xy  
exp(x) вычисление ex  
log(x) натуральный логарифм числа x  
log10(x) десятичный логарифм числа x

Два важных момента.

-   Все функции возвращают значение типа double.
-   Параметры функций – вещественные числа(double), но можно передавать и целые числа. При этом произойдёт неявное преобразование типа. Компилятор из целого числа, например 3, сделает вещественное 3.0.

Примеры.  
Даны длины катетов прямоугольного треугольника. Вычислить длину гипотенузы. Простая задачка на знание теоремы Пифагора.

Листинг 1.
```C
#include <stdio.h>
#include <math.h> // подключаем math.h
int main (void) {
  int a, b, c2;

  scanf("%d",&a);
  scanf("%d",&b);
	
  c2 \=  a\*a + b\*b;
  printf("c = %.2f\\n", sqrt(c2)); 

  return 0;
}
```


Вычислить синус угла ввёденного с клавиатуры. Угол вводится в градусах.

Листинг 2.
```C
#include <stdio.h>
#include <math.h> // подключаем math.h
int main (void) {
  double alpha, sin\_a, pi \= 3.1415926;
 
  scanf("%lf",&alpha);
  alpha \=  alpha\*pi/180; 
  sin\_a \= sin(alpha);
  printf("%.2f\\n", sin\_a); 

  return 0;
}
```


В этой программе есть о чём поговорить. Тригонометрические функции, которые определены в math.h работают с радианной мерой угла. Людям же привычнее работать с градусами. Поэтому в данной программе мы предварительно [перевели значение из градусов в радианы](https://stepik.org/lesson/%D0%90%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D0%BA%D0%B0-%D0%B2-%D0%A1%D0%B8-40857/step/8). Если этого не сделать, результат получится неправильным. Проверьте это самостоятельно.

## Неявное преобразование типов

При явном преобразовании типа мы в скобках перед значением указывали тип, к которому нужно привести данное значение. В неявном преобразовании этого делать не нужно. Компилятор автоматически подберёт необходимый тип.

Неявное преобразование типов осуществляется в следующих случаях:

1.  перед передачей аргументов в функцию (как в нашем примере с корнем. Листинг 1.)
2.  выполнение арифметических операций с разными типами аргументов
3.  перед выполнением присваивания

Правила неявного преобразования типов

-   если выполняются арифметические операции с разными типами аргументов. Оба аргумента приводятся к большему типу.  
    Порядок типов: int < float < double
-   при присваивании. Значение справа от оператора присваивания приводится к типу переменной слева от оператора присваивания. При этом, если больший тип присваивается меньшему, то может произойти потеря точности.

Примеры:

int+float будет автоматически преобразовано к float+float  
float/int будет автоматически преобразовано к float/float  
double\*float будет преобразовано к double\*double  
int = double double будет преобразовано к int с потерей дробной части  
float = int int будет преобразовано к float
[^1] 

 [^1]: https://youngcoder.ru/lessons/4/math_function.php  
