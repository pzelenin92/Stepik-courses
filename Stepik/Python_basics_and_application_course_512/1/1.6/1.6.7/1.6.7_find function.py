def find(x,y):
    finded=False
    def find(x,y):
        nonlocal finded
        if y in classes:#проверка на наличие стартового класса в словаре с классами
            if x==y: # если такой класс есть в словаре, то проверяем на равенство
               print('Yes')
               finded=True
               return # если они равны значит выходим из функции с принтом yes
            if x in classes[y]:# если классы не равны, то проверяем есть ли внутри листа искомый класс x
                print('Yes')
                finded=True
            else: # если классы не равны то проверка внутри листа поэлементно
                for i in classes[y]:
                    if finded==False:# условние нужно чтобы не проверять дальше по элементам в списке, если нашли искомый класс
                         find(x,i)
                    else:
                        return
    find(x,y)
    if finded==False:
        print('No')
#classes={'a':[],'b':['a'],'c':[],'d':['b'],'e':['c','d']}
#x,y='a','e'
classes={
'G':['F'],  # сначала отнаследуем от F, потом его объявим, корректный алгоритм все равно правильно обойдёт граф, независимо что было раньше: наследование или объявление    'A':[],
'B' : ['A'],
'C' : ['A'],
'D' : ['B', 'C'],
'E' : ['D'],
'F' : ['D'],
# а теперь другая ветка наследования
'X':[],
'Y' : ['X', 'A'],  # свяжем две ветки наследования для проверки, обошла ли рекурсия предков Z и предков Y в поисках A
'Z' : ['X'],
'V' : ['Z', 'Y'],
'W' : ['V']
}

lst_q = [  # список введённых запросов
    'A G',      # Yes   # A предок G через B/C, D, F
    'A Z',      # No    # Y потомок A, но не Y
    'A W',      # Yes   # A предок W через Y, V
    'X W',      # Yes   # X предок W через Y, V
    'X QWE',    # No    # нет такого класса QWE
    'A X',      # No    # классы есть, но они нет родства :)
    'X X',      # Yes   # родитель он же потомок
    '1 1',      # No    # несуществующий класс
]

for i in lst_q:
    x,y=str(i).split()
    find(x,y)
